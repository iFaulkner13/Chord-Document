<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Document</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f3f4f6;
        }
        .paper-container {
            background-color: #fff;
            border: 1px solid #d1d5db;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            /* A4 long size bond paper is roughly 8.5 x 13 inches, which is about 816px wide at 96 DPI. */
            max-width: 816px;
        }
        .symbol-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 0.5rem;
        }
        #scoreCanvas {
            width: 100%;
            height: auto;
            border: 1px solid #ccc;
            cursor: text;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        .symbol-button {
            @apply bg-white hover:bg-gray-100 text-gray-800 font-bold py-2 px-4 rounded-md shadow-sm transition-colors duration-150 border border-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400;
        }
    </style>
</head>
<body class="p-8 flex flex-col items-center">

    <!-- Main Container -->
    <div class="max-w-4xl w-full">
        <!-- Header -->
        <h1 id="songTitle" class="text-3xl font-bold text-center mb-8 text-gray-800" contenteditable="true">My Song</h1>

        <!-- Symbol Buttons -->
        <div class="mb-8">
            <h2 class="text-xl font-bold mb-4 text-gray-700">Song Structure</h2>
            <div id="sectionButtons" class="symbol-grid mb-8">
                <!-- Section buttons will be generated by JavaScript -->
            </div>
            <h2 class="text-xl font-bold mb-4 text-gray-700">Chords</h2>
            <div id="chordContainer">
                <!-- Chords will be generated here by letter -->
            </div>
            <h2 class="text-xl font-bold mt-4 mb-4 text-gray-700">Other Symbols</h2>
            <div id="otherSymbolButtons" class="symbol-grid">
                <!-- Other symbol buttons will be generated by JavaScript -->
            </div>
        </div>

        <!-- Document Area -->
        <div class="paper-container rounded-lg mx-auto">
            <canvas id="scoreCanvas"></canvas>
        </div>

        <!-- Control Buttons -->
        <div class="flex justify-center space-x-4 mt-8">
            <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                Clear Page
            </button>
            <button id="newLineBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                New Line
            </button>
            <button id="spaceBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                Space
            </button>
            <button id="backspaceBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                Backspace
            </button>
        </div>
    </div>

    <script>
        // Use a simple check to prevent issues in environments without __app_id
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const sectionButtonsEl = document.getElementById('sectionButtons');
        const otherSymbolButtonsEl = document.getElementById('otherSymbolButtons');
        const clearBtn = document.getElementById('clearBtn');
        const newLineBtn = document.getElementById('newLineBtn');
        const spaceBtn = document.getElementById('spaceBtn');
        const backspaceBtn = document.getElementById('backspaceBtn');
        const canvas = document.getElementById('scoreCanvas');
        const ctx = canvas.getContext('2d');

        // Data structure to hold our document content
        let documentContent = [['']];
        let cursorPosition = { line: 0, index: 0 };
        let highlightStart = null;
        let animationFrameId;

        // Visual parameters
        const lineSpacing = 40;
        const textPadding = 20;
        const symbolPadding = 30;
        // Adjusted max line width to fit the A4 long size
        const maxLineWidth = 750;

        // Symbols to be displayed as buttons, now separated by category
        const sectionSymbols = [
            'INTRO:', 'I:', 'II:', 'III:', 'IV:', 'CHO:', 'BRIDGE:','', '','','','','', 'INTERLUDE:','', 'FINALE:','',
            'INTERFINALE','', 'CODA:'
        ];

        // Chords grouped by the first letter of the chord
        const chordSymbolsByLetter = {
            'A': [
                { text: 'A', display: 'A' },
                { text: 'A/C', display: 'A/C' },
                { text: 'A7', display: 'A<sub>7</sub>' },
                { text: 'A♭', display: 'A♭' },
                { text: 'A♭/C', display: 'A♭/C' },
                { text: 'A♭/D♭', display: 'A♭/D♭' },
                { text: 'A♭/E♭', display: 'A♭/E♭' },
                { text: 'A♭/F', display: 'A♭/F' },
                { text: 'A♭/G♭', display: 'A♭/G♭' },
                { text: 'A♭2/C', display: 'A♭<sup>2</sup>/C' },
                { text: 'A♭7', display: 'A♭<sub>7</sub>' },
                { text: 'Am7', display: 'A<sub>m7</sub>' },
            ],
            'B': [
                { text: 'B♭', display: 'B♭' },
                { text: 'B♭/C', display: 'B♭/C' },
                { text: 'B♭/F', display: 'B♭/F' },
                { text: 'B♭/G', display: 'B♭/G' },
                { text: 'B♭6/G', display: 'B♭<sup>6</sup>/G' },
                { text: 'B♭m', display: 'B♭<sub>m</sub>' },
                { text: 'B♭m2', display: 'B♭m<sup>2</sup>' },
                { text: 'B♭m6/G', display: 'B♭m<sub>6</sub>/G' },
                { text: 'B♭m7', display: 'B♭m<sub>7</sub>' },
                { text: 'B♭m7/A♭', display: 'B♭m<sub>7</sub>/A♭' },
                { text: 'Bm/B♭', display: 'B<sub>m</sub>/B♭' },
            ],
            'C': [
                { text: 'C', display: 'C' },
                { text: 'C/E', display: 'C/E' },
                { text: 'C/G', display: 'C/G' },
                { text: 'Cm7', display: 'C<sub>m7</sub>' },
            ],
            'D': [
                { text: 'D/F', display: 'D/F' },
                { text: 'D/A♭', display: 'D/A♭' },
                { text: 'D♭', display: 'D♭' },
                { text: 'D♭/A♭', display: 'D♭/A♭' },
                { text: 'D♭/B♭', display: 'D♭/B♭' },
                { text: 'D♭/E♭', display: 'D♭/E♭' },
                { text: 'D♭/F', display: 'D♭/F' },
                { text: 'D♭/G♭', display: 'D♭/G♭' },
                { text: 'D♭2', display: 'D♭<sup>2</sup>' },
                { text: 'D♭m7', display: 'D♭m<sub>7</sub>' },
            ],
            'E': [
                { text: 'E♭', display: 'E♭' },
                { text: 'E♭/C', display: 'E♭/C' },
                { text: 'E♭/G', display: 'E♭/G' },
                { text: 'E♭m6/C', display: 'E♭m<sub>6</sub>/C' },
                { text: 'E♭m7', display: 'E♭m<sub>7</sub>' },
            ],
            'F': [
                { text: 'F', display: 'F' },
                { text: 'F/A', display: 'F/A' },
                { text: 'F/B♭', display: 'F/B♭' },
                { text: 'F/C', display: 'F/C' },
                { text: 'F/E♭', display: 'F/E♭' },
                { text: 'F/G', display: 'F/G' },
                { text: 'F+', display: 'F+' },
                { text: 'F+/B♭', display: 'F+/B♭' },
                { text: 'F7', display: 'F<sub>7</sub>' },
                { text: 'Fm6/D', display: 'Fm<sub>6</sub>/D' },
                { text: 'Fm7', display: 'Fm<sub>7</sub>' },
                { text: 'Fsus', display: 'F<sub>sus</sub>' },
            ],
            'G': [
                { text: 'G', display: 'G' },
                { text: 'G/A', display: 'G/A' },
                { text: 'G/B♭', display: 'G/B♭' },
                { text: 'G7', display: 'G<sub>7</sub>' },
                { text: 'G6', display: 'G<sup>6</sup>' },
                { text: 'G♭', display: 'G♭' },
                { text: 'G♭/A♭', display: 'G♭/A♭' },
                { text: 'G♭/B♭', display: 'G♭/B♭' },
                { text: 'G♭/D♭', display: 'G♭/D♭' },
                { text: 'G♭/E♭', display: 'G♭/E♭' },
                { text: 'G♭6/B♭', display: 'G♭<sup>6</sup>/B♭' },
                { text: 'G♭M7', display: 'G♭M<sup>7</sup>' },
                { text: 'G♭m6', display: 'G♭m<sub>6</sub>' },
                { text: 'G♭m6/A', display: 'G♭m<sub>6</sub>/A' },
                { text: 'Gm/A', display: 'G<sub>m</sub>/A' },
                { text: 'Gm7', display: 'G<sub>m7</sub>' },
            ]
        };

        const otherSymbols = [
            { text: 'Repeat Section', display: ':|' },
            { text: 'Pause', display: '⨆' },
            { text: 'Double Barline', display: '⫽' },
            { text: 'Fermata', display: '𝄬' },
            { text: 'Dotted Quarter Note', display: '♩•' },
            { text: 'Whole Note', display: '𝄡' },
            { text: 'Half Note', display: '𝄢' },
            { text: 'Quarter Note', display: '𝄣' },
            { text: 'Eighth Note', display: '𝄤' },
            { text: 'Sixteenth Note', display: '𝄥' },
            { text: 'Whole Rest', display: '𝄺' },
            { text: 'Half Rest', display: '𝄻' },
            { text: 'Quarter Rest', display: '𝄼' },
            { text: 'Eighth Rest', display: '𝄽' },
            { text: 'Sixteenth Rest', display: '𝄾' },
            { text: 'Dot', display: '•' },
            { text: 'emdash', display: '—' },
            { text: 'en dash', display: '–' },
            { text: 'Piano', display: 'p' },
            { text: 'Forte', display: 'f' },
            { text: 'Mezzo-Piano', display: 'mp' },
            { text: 'Mezzo-Forte', display: 'mf' },
        ];

        // Function to draw formatted text on the canvas with correct spacing
        function drawFormattedText(text, x, y, ctx) {
            ctx.font = 'bold 28px Montserrat';
            ctx.fillStyle = '#1f2937';
            ctx.textBaseline = 'middle';
            let currentX = x;

            const parts = text.split(/(♭|#|<sub>.*?<\/sub>|<sup>.*?<\/sup>|♩|•|𝄡|𝄢|𝄣|𝄤|𝄥|𝄺|𝄻|𝄼|𝄽|𝄾)/g).filter(Boolean);

            parts.forEach(part => {
                let subMatch = part.match(/<sub>(.*?)<\/sub>/);
                let supMatch = part.match(/<sup>(.*?)<\/sup>/);

                if (subMatch) {
                    ctx.font = 'bold 16px Montserrat';
                    ctx.fillText(subMatch[1], currentX, y + 10);
                    currentX += ctx.measureText(subMatch[1]).width;
                } else if (supMatch) {
                    ctx.font = 'bold 16px Montserrat';
                    ctx.fillText(supMatch[1], currentX, y - 10);
                    currentX += ctx.measureText(supMatch[1]).width;
                } else if (['♩', '𝄡', '𝄢', '𝄣', '𝄤', '𝄥'].includes(part)) {
                    ctx.font = 'bold 28px Montserrat';
                    ctx.fillText(part, currentX, y);
                    currentX += ctx.measureText(part).width;
                } else if (['𝄺', '𝄻', '𝄼', '𝄽', '𝄾'].includes(part)) {
                    ctx.font = 'bold 28px Montserrat';
                    ctx.fillText(part, currentX, y);
                    currentX += ctx.measureText(part).width;
                } else if (part === '•') {
                    ctx.font = 'bold 28px Montserrat';
                    ctx.fillText('•', currentX, y + 10);
                    currentX += ctx.measureText('•').width;
                } else {
                    ctx.font = 'bold 28px Montserrat';
                    ctx.fillText(part, currentX, y);
                    currentX += ctx.measureText(part).width;
                }
            });

            // Add fixed padding after each symbol to ensure consistent spacing
            currentX += symbolPadding;
            
            return currentX - x;
        }

        // Main function to draw the document
        function drawDocument() {
            // Adjust canvas height to fit all lines
            canvas.height = documentContent.length * lineSpacing + (2 * textPadding);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            documentContent.forEach((line, lineIndex) => {
                let xPosition = textPadding;
                const yPosition = (lineIndex * lineSpacing) + textPadding + 15;
                
                line.forEach((symbol, symbolIndex) => {
                    const cleanSymbol = symbol.replace(/(<([^>]+)>)/ig, '');
                    const symbolWidth = ctx.measureText(cleanSymbol).width;
                    
                    // Draw highlight
                    if (isHighlighted({ line: lineIndex, index: symbolIndex })) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; // Light blue highlight
                        ctx.fillRect(xPosition - symbolPadding/2, yPosition - 25, symbolWidth + symbolPadding, lineSpacing - 10);
                        ctx.restore();
                    }

                    // Draw the formatted symbol
                    drawFormattedText(symbol, xPosition, yPosition, ctx);
                    xPosition += symbolWidth + symbolPadding;
                });
            });
        }

        function isHighlighted(pos) {
            if (!highlightStart) return false;
            
            const startLine = highlightStart.line;
            const startIndex = highlightStart.index;
            const endLine = cursorPosition.line;
            const endIndex = cursorPosition.index;

            const minLine = Math.min(startLine, endLine);
            const maxLine = Math.max(startLine, endLine);
            const minIndex = (startLine === minLine && startLine === endLine) ? Math.min(startIndex, endIndex) : startIndex;
            const maxIndex = (endLine === maxLine && startLine === endLine) ? Math.max(startIndex, endIndex) : endIndex;

            return (pos.line > minLine || (pos.line === minLine && pos.index >= minIndex)) &&
                   (pos.line < maxLine || (pos.line === maxLine && pos.index < maxIndex));
        }

        function drawCursor() {
            // Draw a blinking cursor at the cursor position
            const currentTime = Date.now();
            if (currentTime % 1000 < 500) {
                let xPosition = textPadding;
                for (let i = 0; i < cursorPosition.index; i++) {
                    const symbol = documentContent[cursorPosition.line][i];
                    xPosition += ctx.measureText(symbol.replace(/(<([^>]+)>)/ig, '')).width + symbolPadding;
                }
                const yPosition = (cursorPosition.line * lineSpacing) + textPadding + 15;
                ctx.fillRect(xPosition - 2, yPosition - 20, 2, 20);
            }
        }
        
        function animate() {
            drawDocument();
            drawCursor();
            animationFrameId = requestAnimationFrame(animate);
        }

        // Function to add a symbol at the cursor position
        function addSymbolToDocument(symbol) {
            if (highlightStart) {
                // Delete highlighted content first
                deleteHighlightedContent();
            }

            // Check if the new symbol will fit on the current line
            let currentLineTextWidth = 0;
            for (let i = 0; i < documentContent[cursorPosition.line].length; i++) {
                currentLineTextWidth += ctx.measureText(documentContent[cursorPosition.line][i].replace(/(<([^>]+)>)/ig, '')).width + symbolPadding;
            }
            const newSymbolWidth = ctx.measureText(symbol.replace(/(<([^>]+)>)/ig, '')).width + symbolPadding;
            const newLineWidth = currentLineTextWidth + newSymbolWidth;

            // If the new symbol doesn't fit, create a new line
            if (newLineWidth > maxLineWidth) {
                addNewLine();
            }
            
            documentContent[cursorPosition.line].splice(cursorPosition.index, 0, symbol);
            cursorPosition.index++;
            drawDocument();
        }

        // Function to delete the symbol before the cursor
        function deleteSymbol() {
            if (highlightStart) {
                deleteHighlightedContent();
                return;
            }

            if (cursorPosition.index > 0) {
                documentContent[cursorPosition.line].splice(cursorPosition.index - 1, 1);
                cursorPosition.index--;
            } else if (cursorPosition.line > 0) {
                // If at the start of a line, delete the newline
                const previousLine = documentContent[cursorPosition.line - 1];
                const currentLineContent = documentContent[cursorPosition.line];
                documentContent.splice(cursorPosition.line, 1);
                cursorPosition.line--;
                cursorPosition.index = previousLine.length;
                documentContent[cursorPosition.line] = documentContent[cursorPosition.line].concat(currentLineContent);
            }
            drawDocument();
        }

        function deleteHighlightedContent() {
            const startLine = highlightStart.line;
            const startIndex = highlightStart.index;
            const endLine = cursorPosition.line;
            const endIndex = cursorPosition.index;
            
            if (startLine === endLine) {
                documentContent[startLine].splice(Math.min(startIndex, endIndex), Math.abs(endIndex - startIndex));
                cursorPosition.index = Math.min(startIndex, endIndex);
            } else {
                // Not handling multi-line deletion for this simple example.
                documentContent[startLine] = []; // Clear the line
                cursorPosition.line = startLine;
                cursorPosition.index = 0;
            }

            highlightStart = null;
            drawDocument();
        }

        // Function to add a new line
        function addNewLine() {
            const newContent = documentContent[cursorPosition.line].splice(cursorPosition.index);
            documentContent.splice(cursorPosition.line + 1, 0, newContent);
            cursorPosition.line++;
            cursorPosition.index = 0;
            drawDocument();
        }

        // Function to clear the document
        function clearDocument() {
            documentContent = [['']];
            cursorPosition = { line: 0, index: 0 };
            highlightStart = null;
            drawDocument();
        }

        // Function to handle canvas clicks
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedLine = Math.floor((y - textPadding) / lineSpacing);
            if (clickedLine >= 0 && clickedLine < documentContent.length) {
                let xPosition = textPadding;
                let foundIndex = 0;
                for (let i = 0; i < documentContent[clickedLine].length; i++) {
                    const symbol = documentContent[clickedLine][i].replace(/(<([^>]+)>)/ig, '');
                    const symbolWidth = ctx.measureText(symbol).width + symbolPadding;
                    if (x >= xPosition && x <= xPosition + symbolWidth) {
                        foundIndex = i;
                        break;
                    }
                    xPosition += symbolWidth;
                }
                cursorPosition = { line: clickedLine, index: foundIndex };
                highlightStart = null;
                drawDocument();
            }
        }
        
        // Function to handle mouse down for highlighting
        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedLine = Math.floor((y - textPadding) / lineSpacing);
            if (clickedLine >= 0 && clickedLine < documentContent.length) {
                let xPosition = textPadding;
                let foundIndex = 0;
                for (let i = 0; i < documentContent[clickedLine].length; i++) {
                    const symbol = documentContent[clickedLine][i].replace(/(<([^>]+)>)/ig, '');
                    const symbolWidth = ctx.measureText(symbol).width + symbolPadding;
                    if (x >= xPosition && x <= xPosition + symbolWidth) {
                        foundIndex = i;
                        break;
                    }
                    xPosition += symbolWidth;
                }
                highlightStart = { line: clickedLine, index: foundIndex };
                cursorPosition = { line: clickedLine, index: foundIndex };
                drawDocument();
                canvas.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            }
        }

        // Function to handle mouse move for highlighting
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedLine = Math.floor((y - textPadding) / lineSpacing);
            if (clickedLine >= 0 && clickedLine < documentContent.length) {
                let xPosition = textPadding;
                let foundIndex = 0;
                for (let i = 0; i < documentContent[clickedLine].length; i++) {
                    const symbol = documentContent[clickedLine][i].replace(/(<([^>]+)>)/ig, '');
                    const symbolWidth = ctx.measureText(symbol).width + symbolPadding;
                    if (x >= xPosition && x <= xPosition + symbolWidth) {
                        foundIndex = i;
                        break;
                    }
                    xPosition += symbolWidth;
                }
                cursorPosition = { line: clickedLine, index: foundIndex };
                drawDocument();
            }
        }

        // Function to handle mouse up to stop highlighting
        function handleMouseUp() {
            canvas.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }

        // Function to render buttons
        function renderButtons() {
            // Render section buttons
            sectionSymbols.forEach(symbol => {
                const button = document.createElement('button');
                button.textContent = symbol;
                button.className = 'symbol-button';
                button.onclick = () => addSymbolToDocument(symbol);
                sectionButtonsEl.appendChild(button);
            });
            
            // Render chords grouped by letter
            const chordContainerEl = document.getElementById('chordContainer');
            for (const letter in chordSymbolsByLetter) {
                const letterHeading = document.createElement('h3');
                letterHeading.className = 'text-lg font-bold mt-4 mb-2 text-gray-600';
                letterHeading.textContent = letter;
                chordContainerEl.appendChild(letterHeading);

                const letterGrid = document.createElement('div');
                letterGrid.className = 'symbol-grid';
                chordSymbolsByLetter[letter].forEach(symbol => {
                    const button = document.createElement('button');
                    button.className = 'symbol-button';
                    button.innerHTML = symbol.display;
                    button.onclick = () => addSymbolToDocument(symbol.display);
                    letterGrid.appendChild(button);
                });
                chordContainerEl.appendChild(letterGrid);
            }


            // Render other symbols
            otherSymbols.forEach(symbol => {
                const button = document.createElement('button');
                button.className = 'symbol-button';
                button.innerHTML = symbol.display;
                button.onclick = () => addSymbolToDocument(symbol.display);
                otherSymbolButtonsEl.appendChild(button);
            });
        }

        // Event Listeners
        window.onload = () => {
            canvas.width = canvas.parentElement.clientWidth;
            drawDocument();
            renderButtons();
            animate();
        };

        window.addEventListener('resize', () => {
            canvas.width = canvas.parentElement.clientWidth;
        });

        canvas.addEventListener('mousedown', handleMouseDown);
        clearBtn.onclick = clearDocument;
        newLineBtn.onclick = addNewLine;
        spaceBtn.onclick = () => addSymbolToDocument(' ');
        backspaceBtn.onclick = deleteSymbol;
    </script>
</body>
</html>
