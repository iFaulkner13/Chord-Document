<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Document</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
    <link rel="stylesheet" href="chord/style.css">    
    </style>
</head>
<body class="p-8 flex flex-col items-center">

    <!-- Main Container -->
    <div class="max-w-4xl w-full">
        <!-- Header -->
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">Chord Document</h1>

        <!-- Symbol Buttons -->
        <div class="mb-8">
            <h2 class="text-xl font-bold mb-4 text-gray-700">Song Structure</h2>
            <div id="sectionButtons" class="symbol-grid mb-8">
                <!-- Section buttons will be generated by JavaScript -->
            </div>
            <h2 class="text-xl font-bold mb-4 text-gray-700">Chords</h2>
            <div id="chordButtons" class="symbol-grid">
                <!-- Chord buttons will be generated by JavaScript -->
            </div>
            <h2 class="text-xl font-bold mt-4 mb-4 text-gray-700">Other Symbols</h2>
            <div id="otherSymbolButtons" class="symbol-grid">
                <!-- Other symbol buttons will be generated by JavaScript -->
            </div>
        </div>

        <!-- Document Area -->
        <div class="paper-container rounded-lg mx-auto">
            <canvas id="scoreCanvas"></canvas>
        </div>

        <!-- Control Buttons -->
        <div class="flex justify-center space-x-4 mt-8">
            <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                Clear Page
            </button>
            <button id="newLineBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                New Line
            </button>
            <button id="deleteBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none">
                Delete
            </button>
        </div>
    </div>

    <script>
        // Use a simple check to prevent issues in environments without __app_id
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const sectionButtonsEl = document.getElementById('sectionButtons');
        const chordButtonsEl = document.getElementById('chordButtons');
        const otherSymbolButtonsEl = document.getElementById('otherSymbolButtons');
        const clearBtn = document.getElementById('clearBtn');
        const newLineBtn = document.getElementById('newLineBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const canvas = document.getElementById('scoreCanvas');
        const ctx = canvas.getContext('2d');

        // Data structure to hold our document content
        let documentContent = [['']];
        let cursorPosition = { line: 0, index: 0 };
        let highlightStart = null;
        let animationFrameId;

        // Visual parameters
        const lineSpacing = 40;
        const textPadding = 20;
        const symbolPadding = 30;
        const maxLineWidth = 750;

        // Symbols to be displayed as buttons, now separated by category
        const sectionSymbols = [
            'INTRO:', 'I:', 'II:', 'III:', 'IV:', 'CHO:','BRIDGE:','FINALE:','CODA:'
        ];
        
        const chordSymbols = [
            'F', 'C', 'G', 'Am', 'Dm', 'Em',
            'F/C', 'Bb/C', 'F/Bb', 'A/C',
            'G7', 'Cm7', 'Gm7', 'Fm7', 'Bb7',
            'F/A', 'C/G', 'Am/D', 'C/E'
        ];

        const otherSymbols = [
            '-', 'â€¢'
        ];

        // Main function to draw the document
        function drawDocument() {
            // Adjust canvas height to fit all lines
            canvas.height = documentContent.length * lineSpacing + (2 * textPadding);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.font = '28px Courier Prime';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'left';

            documentContent.forEach((line, lineIndex) => {
                let xPosition = textPadding;
                const yPosition = (lineIndex * lineSpacing) + textPadding + 15;
                
                line.forEach((symbol, symbolIndex) => {
                    // Draw highlight
                    if (isHighlighted({ line: lineIndex, index: symbolIndex })) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; // Light blue highlight
                        ctx.fillRect(xPosition, yPosition - 25, ctx.measureText(symbol).width + symbolPadding, lineSpacing - 10);
                        ctx.restore();
                    }

                    ctx.fillText(symbol, xPosition, yPosition);
                    xPosition += ctx.measureText(symbol).width + symbolPadding;
                });
            });
        }

        function isHighlighted(pos) {
            if (!highlightStart) return false;
            
            const startLine = highlightStart.line;
            const startIndex = highlightStart.index;
            const endLine = cursorPosition.line;
            const endIndex = cursorPosition.index;

            const minLine = Math.min(startLine, endLine);
            const maxLine = Math.max(startLine, endLine);
            const minIndex = (startLine === minLine) ? Math.min(startIndex, endIndex) : Math.max(startIndex, endIndex);
            const maxIndex = (endLine === maxLine) ? Math.max(startIndex, endIndex) : Math.min(startIndex, endIndex);

            return (pos.line > minLine || (pos.line === minLine && pos.index >= minIndex)) &&
                   (pos.line < maxLine || (pos.line === maxLine && pos.index < maxIndex));
        }

        function drawCursor() {
            // Draw a blinking cursor at the cursor position
            const currentTime = Date.now();
            if (currentTime % 1000 < 500) {
                let xPosition = textPadding;
                for (let i = 0; i < cursorPosition.index; i++) {
                    const symbol = documentContent[cursorPosition.line][i];
                    xPosition += ctx.measureText(symbol).width + symbolPadding;
                }
                const yPosition = (cursorPosition.line * lineSpacing) + textPadding + 15;
                ctx.fillRect(xPosition - 2, yPosition - 20, 2, 20);
            }
        }
        
        function animate() {
            drawDocument();
            drawCursor();
            animationFrameId = requestAnimationFrame(animate);
        }

        // Function to add a symbol at the cursor position
        function addSymbolToDocument(symbol) {
            if (highlightStart) {
                // Delete highlighted content first
                deleteHighlightedContent();
            }

            // Check if the new symbol will fit on the current line
            let currentLineTextWidth = 0;
            for (let i = 0; i < documentContent[cursorPosition.line].length; i++) {
                currentLineTextWidth += ctx.measureText(documentContent[cursorPosition.line][i]).width + symbolPadding;
            }
            const newSymbolWidth = ctx.measureText(symbol).width + symbolPadding;
            const newLineWidth = currentLineTextWidth + newSymbolWidth;

            // If the new symbol doesn't fit, create a new line
            if (newLineWidth > maxLineWidth) {
                addNewLine();
            }
            
            documentContent[cursorPosition.line].splice(cursorPosition.index, 0, symbol);
            cursorPosition.index++;
            drawDocument();
        }

        // Function to delete the symbol before the cursor
        function deleteSymbol() {
            if (highlightStart) {
                deleteHighlightedContent();
                return;
            }

            if (cursorPosition.index > 0) {
                documentContent[cursorPosition.line].splice(cursorPosition.index - 1, 1);
                cursorPosition.index--;
            } else if (cursorPosition.line > 0) {
                // If at the start of a line, delete the newline
                const previousLine = documentContent[cursorPosition.line - 1];
                const currentLineContent = documentContent[cursorPosition.line];
                documentContent.splice(cursorPosition.line, 1);
                cursorPosition.line--;
                cursorPosition.index = previousLine.length;
                documentContent[cursorPosition.line] = documentContent[cursorPosition.line].concat(currentLineContent);
            }
            drawDocument();
        }

        function deleteHighlightedContent() {
            // This is a simplified deletion. For full functionality, you'd need to handle multi-line deletes.
            const startLine = highlightStart.line;
            const startIndex = highlightStart.index;
            const endLine = cursorPosition.line;
            const endIndex = cursorPosition.index;
            
            if (startLine === endLine) {
                documentContent[startLine].splice(Math.min(startIndex, endIndex), Math.abs(endIndex - startIndex));
                cursorPosition.index = Math.min(startIndex, endIndex);
            } else {
                // Not handling multi-line deletion for this simple example.
                documentContent[startLine] = []; // Clear the line
                cursorPosition.line = startLine;
                cursorPosition.index = 0;
            }

            highlightStart = null;
            drawDocument();
        }

        // Function to add a new line
        function addNewLine() {
            const newContent = documentContent[cursorPosition.line].splice(cursorPosition.index);
            documentContent.splice(cursorPosition.line + 1, 0, newContent);
            cursorPosition.line++;
            cursorPosition.index = 0;
            drawDocument();
        }

        // Function to clear the document
        function clearDocument() {
            documentContent = [['']];
            cursorPosition = { line: 0, index: 0 };
            highlightStart = null;
            drawDocument();
        }

        // Function to handle canvas clicks
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedLine = Math.floor((y - textPadding) / lineSpacing);
            if (clickedLine >= 0 && clickedLine < documentContent.length) {
                let xPosition = textPadding;
                let foundIndex = 0;
                for (let i = 0; i < documentContent[clickedLine].length; i++) {
                    const symbol = documentContent[clickedLine][i];
                    const symbolWidth = ctx.measureText(symbol).width + symbolPadding;
                    if (x >= xPosition && x <= xPosition + symbolWidth) {
                        foundIndex = i;
                        break;
                    }
                    xPosition += symbolWidth;
                }
                cursorPosition = { line: clickedLine, index: foundIndex };
                highlightStart = null;
                drawDocument();
            }
        }
        
        // Function to handle mouse down for highlighting
        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedLine = Math.floor((y - textPadding) / lineSpacing);
            if (clickedLine >= 0 && clickedLine < documentContent.length) {
                let xPosition = textPadding;
                let foundIndex = 0;
                for (let i = 0; i < documentContent[clickedLine].length; i++) {
                    const symbol = documentContent[clickedLine][i];
                    const symbolWidth = ctx.measureText(symbol).width + symbolPadding;
                    if (x >= xPosition && x <= xPosition + symbolWidth) {
                        foundIndex = i;
                        break;
                    }
                    xPosition += symbolWidth;
                }
                highlightStart = { line: clickedLine, index: foundIndex };
                cursorPosition = { line: clickedLine, index: foundIndex };
                drawDocument();
                canvas.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            }
        }

        // Function to handle mouse move for highlighting
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedLine = Math.floor((y - textPadding) / lineSpacing);
            if (clickedLine >= 0 && clickedLine < documentContent.length) {
                let xPosition = textPadding;
                let foundIndex = 0;
                for (let i = 0; i < documentContent[clickedLine].length; i++) {
                    const symbol = documentContent[clickedLine][i];
                    const symbolWidth = ctx.measureText(symbol).width + symbolPadding;
                    if (x >= xPosition && x <= xPosition + symbolWidth) {
                        foundIndex = i;
                        break;
                    }
                    xPosition += symbolWidth;
                }
                cursorPosition = { line: clickedLine, index: foundIndex };
                drawDocument();
            }
        }

        // Function to handle mouse up to stop highlighting
        function handleMouseUp() {
            canvas.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }

        // Function to render buttons
        function renderButtons() {
            // Render section buttons
            sectionSymbols.forEach(symbol => {
                const button = document.createElement('button');
                button.textContent = symbol;
                button.className = 'symbol-button';
                button.onclick = () => addSymbolToDocument(symbol);
                sectionButtonsEl.appendChild(button);
            });
            
            // Render chord buttons
            chordSymbols.forEach(symbol => {
                const button = document.createElement('button');
                button.textContent = symbol;
                button.className = 'symbol-button';
                button.onclick = () => addSymbolToDocument(symbol);
                chordButtonsEl.appendChild(button);
            });

            // Render other symbols
            otherSymbols.forEach(symbol => {
                const button = document.createElement('button');
                button.textContent = symbol;
                button.className = 'symbol-button';
                button.onclick = () => addSymbolToDocument(symbol);
                otherSymbolButtonsEl.appendChild(button);
            });
        }

        // Event Listeners
        window.onload = () => {
            canvas.width = canvas.parentElement.clientWidth;
            drawDocument();
            renderButtons();
            animate();
        };

        window.addEventListener('resize', () => {
            canvas.width = canvas.parentElement.clientWidth;
        });

        canvas.addEventListener('mousedown', handleMouseDown);
        clearBtn.onclick = clearDocument;
        newLineBtn.onclick = addNewLine;
        deleteBtn.onclick = deleteSymbol;
    </script>
</body>
</html>
